# [优化相关](https://github.com/Summer-Felix/Database/blob/master/MySQL/优化相关.md) #

## [Explain](http://b72820a1.wiz03.com/share/s/2Ta22x20o4jW2IZNfI1XAGW30wawI70GGkoQ2k40bZ2_CNx5) ##

| EXPLAIN(列)| 含义 |
| :------ | :------ |
| id | 包含一组数字，表示查询中执行 select 子句或操作表的顺序 </br> 当引用其他查询结果做 union 时，该值为 null，且 table 列的值为 union（m,n），意思是把id为m和n的查询结果做 union。 </br> id 相同，可以认为是一组，执行顺序由上至下 </br> 如果是子查询，id 的序号会递增 </br> id 值越大优先级越高，越先被执行 |
| select_type | 表示查询中每个 select 子句的类型（简单 、复杂） </br> simple (简单)       : 表示此查询不包含 UNION 查询或 子查询 </br> primary (主)        : 查询中若包含复杂的子部分，则最外层查询为 primary </br> subquery (子查询)   : 在 SELECT 或 WHERE 列表中包含了子查询，该子查询被标记为 SUBQUERY </br> union (联合)        : 若第二个select出现在union之后，则被标记为union，如果有多个union，则除第一个select之外，后续的都是union。 </br> dependent union    : 在union中的第二个及以后的查询语句，依赖于外层查询。 </br> union result       : union的结果，id列为null，table列显示了是由哪几个查询的结果做的union。 </br> dependent query    ：子查询中的第一个查询，依赖于外部查询。 </br> derived            ：在FROM列表中包含的子查询被标记为DERIVED（衍生）。若UNION包含在 FROM子句的子查询中，外层SELECT将被标记为DERIVED </br> materialized       ：物化子查询 </br> dependent subquery : 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. </br> uncacheable union  ：该查询是union查询中的第二个及以后的查询语句，且整个union查询语句是一个uncacheable subquery。 </br>  </br> dependent subquery评估和uncacheable subquery评估不同。 </br> dependent subquery对于外部查询中的不同的值只计算一次。 </br> 而uncacheable subquery对于外部查询中的每一行都重新评估一次。 |
| table | table 查询结果出自哪张表。可以是具体的表名，也可以是以下的值： </br> union M，N：id为M和N的查询结果做union </br> derivedN ：参考id为N的查询的衍生查询 </br> subqueryN ：参考id为N的物化子查询 |
| type | type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： </br> system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL  </br> 一般来说，得保证查询至少达到range级别，最好能达到ref。 </br>  </br> system : 表中只有一条数据. 这个类型是特殊的 const 类型. </br> const : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可. </br> 例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的. </br> eq_ref : 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高 </br> ref : 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. </br> 例如下面这个例子中, 就使用到了 ref 类型的查询fulltext：全文索引。 </br> fulltext ：全文索引。 </br> ref_or_null ：连接方式跟ref相似，但是增加了一个额外的搜索条件，包含null值。这种连接方式优化大多用于解决子查询问题。在下面的例子中，mysql使用ref_or_null连接方式处理ref_table </br> index merge ：这种连接方式表明使用了index merge优化。在这种情况下，explain输出的列中，key列包含用到的索引的列表，key_len列包含用到的列的最大长度的列表。see Section 8.2.1.4, “Index Merge Optimization”. </br> unique_subquery ：这种方式用于在使用in关键字进行子查询时，代替ref连接方式。 </br> index_subquery ：这种连接方式类似于unique_subquery，代替了IN方式的子查询，但是用于非唯一索引的子查询。 </br> range  : 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中. </br> 当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个 </br> index  : 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据. </br> index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index </br> ALL : 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的 |
| possible_keys | 指 MySQL在搜索表记录时可能使用哪个索引。 </br> possible_keys里面所包含的索引可能在实际的使用中没用到。如果这个字段的值是null，就表示没有索引被用到。 </br> 这种情况下，就可以检查 where子句中哪些字段那些字段适合增加索引以提高查询的性能。 |
| key | 此次查询中确切使用到的索引. </br> 很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 </br> 当没有任何索引被用到的时候，这个字段的值就是null。 </br> 想要让mysql强行使用或者忽略在 possible_keys字段中的索引列表，可以在查询语句中使用关键字force index, use index,或 ignore index。 </br> 如果是 myisam 和 bdb 类型表，可以使用 analyzetable 来帮助分析使用使用哪个索引更好。 </br> 如果是 myisam类型表，运行命令 myisamchk –analyze也是一样的效果。 |
| key_len | 使用的索引的长度。在不损失精确性的情况下，长度越短越好 |
| ref | 哪个字段或常数与 key 一起被使用 |
| rows | 显示此查询一共扫描了多少行. 这个是一个估计值 |
| filtered | 表示此查询条件所过滤的数据的百分比 |
| Extra | 关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢 </br> extra列返回的描述的意义 </br> Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 </br> Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了 </br> Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 </br> Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 </br> Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 </br> Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 </br> Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序） </br> system 表只有一行：system表。这是const连接类型的特殊情况 </br> const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待 </br> eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用 </br> ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好 </br> range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况 </br> index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据） </br> ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免 </br> 其中， </br> type=const 表示通过索引一次就找到了， </br> key=primary 表示使用了主键 </br> type=all, 表示为全表扫描， </br> key=null 表示没用到索引； </br> type=ref, 因为这时认为是多个匹配行，在联合查询中，一般为REF
